\section{Tracking Text Authorship}
\label{sec:diff-tracking}

To answer the question of which author contributed what text to a
collaborative document
we consider the problem, without loss of generality, for
a single article $\article{} \in \articles$,
with $n > 0$ revisions given by
\begin{equation*}
\versions{\article{}} = [ \version{1}, \version{2}, \ldots, \version{n} ].
\end{equation*}
We define the content of version \version{i}
as being a sequence of $l_i \ge 0$ words for all $0 < i \le n$,
given by:
\begin{equation}
\words{\version{i}} = [ w_1, w_2, \ldots, w_{l_i} ].
\label{def:words}
\end{equation}
For us, a \intro{word} is a whitespace-delimited sequence of
characters in the Wiki markup language:
we work at the level of such markup language, rather than at the level
of the HTML produced by the wiki engine.
We also desire a function that gives the \intro{author} of a
revision; for a user $u \in \users$
that edited and committed article $a$ when version \version{i-1}
was the previous version which user $u$ edited to create \version{i},
we define:
\begin{equation}
\revauthor{\version{i}} = u.
\label{def:revauthor}
\end{equation}
The MediaWiki software associates user $u$ to version \version{i} in
the database (or the IP address, in the case of anonymous users),
so that this information is readily available.




We conceive the problem of author attribution as a recursive relation:
the attribution of words in some version of the document depends on the
attribution of matching words from earlier versions.
At an abstract level, we can discover the inductive step by examining
the first several versions.
Clearly, for \version{1}, we have the author of the edit,
\revauthor{\version{1}}, as the author of each individual word.
To track the authorship of words in \version{2}, there are two cases:
\begin{enumerate}
\item A sequence of words in \version{2} also exists in \version{1}.
	In this case, we retain the original authorship of the words,
	\revauthor{\version{1}}.
\item A sequence of words in \version{2} does not also exist in \version{1}.
	In this case, the sequence must have been inserted by
	\revauthor{\version{2}}, and we assign authorship accordingly.
\end{enumerate}
Word authorship in \version{3} is similar to the situation in
\version{2}, with an additional case:
\begin{enumerate}
\item A sequence of words in \version{3} also exists in \version{2}.
	In this case, we retain the original authorship of the words
	that was determined for \version{2}.
\item A sequence of words in \version{3} does not also exist in \version{2},
	but does exist in \version{1}.
	Again, we retain the original authorship of the words, as it was
	determined for \version{1}.
\item A sequence of words in \version{3} does not exist in any previous
	revision.
	This sequence must have been inserted by \revauthor{\version{3}}.
\end{enumerate}

The general flavor of the computation is now clear, but to describe it
more precisely, we need some additional definitions.
For a given revision, we need to know the ordered list of revisions
earlier than \version{i}:
\begin{equation}
    \prevrevs{\version{i}} = \left[ \version{j} \colon  0 < j < i \right]
\label{def:prevrevs}
\end{equation}
And for some particular
word $w_r$ which is the $r^{\text{th}}$ word of $\words{\version{i}}$,
we need a function which will return the location of the so-called
``best match'' from a list of earlier revisions:
\begin{equation}
    \match{\version{i}, r, \prevrevs{\version{i}}} =
    \begin{cases}
	(\version{k}, s) & \text{if there is a best match $w_s$ occurring in \version{k}.} \\
	\emptyset & \text{if there is no match.} \\
    \end{cases}
\label{def:bestmatch}
\end{equation}
where $\version{k} \in \prevrevs{\version{i}}$ since we are only
interested in matches with earlier revisions; we will better describe
this calculation in the next section.

This definition of $\match{}$ is extremely general in that it only
defines the inputs and outputs of the function; it merely
says that word $w_r$ of \version{i} matches with some other word $w_s$
of \version{k}, where \version{k} is in the past of \version{i}.
There is no restriction, in this definition, that $w_s$ be the earliest
(or latest) match in the history of revisions, or that it even be
the exact same word (as in the case of misspellings).
The details of the strategy to rank matches and determine the best match
are application dependent, and you can imagine many refinements to how
matches are made.
For example, consider the word ``score'': in isolation it is fairly
unmemorable, but as part of the quotation ``four score and seven years
ago'' it becomes a signature that allows nearly any American
schoolchild to identify the author.
We felt that identifying this ``context'' for a word was important to
correctly finding matches, so WikiTrust gives preference to matching
contiguous sequences of text.
This is described in more detail in the next section.

We can use the same idea of a recursive relation to define
the author of each word $w_j \in \words{\version{i}}$:
\begin{equation}
\txtauthor{\version{i}, j} =
    \begin{cases}
	\txtauthor{\version{k}, s}, & \text{if }
	\match{\version{i}, j, \prevrevs{\version{i}}} = (\version{k}, s) \\
	\revauthor{\version{i}}, & \text{if there is no best match text. } \\
    \end{cases}
\label{def:txtauthor}
\end{equation}

