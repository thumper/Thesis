\section{Conclusion}

Our experiment of this chapter starts with the data used by the
WikiTrust submission in the PAN~2010 vandalism detection
task~\cite{Adler2010b}, and compares the performance achieved
in~\cite{Potthast2010b}
with the performance achieved by adding author reputation as a feature.
The result is a notable increase in predictive ability, demonstrating
the value of maintaining author reputation scores as described in
Chapter~\ref{ch:reputation}.
The current system is limited to tracking reputations only for
registered users, but we are still able to achieve a precision of 67.2\%
and recall of 40.1\% during stratified ten-fold cross validation.
Due to the large class imbalance, there's the possibility that the
stratification leads to small training sets that don't cover the
diversity of behaviors exhibited by vandals, limiting the predictive
ability of machine learning algorithms.

Although the results of our experiment were quite positive, there are
several further avenues that can be explored.
West~\etal~\cite{West2010} create reputations for several different
``entities'' based on edit metadata (\eg article reputation, category
reputation, and country reputation based on IP geolocation), but the
entities and method of computing reputation are completely different
from the choices made within WikiTrust.
The idea of using geographic entities can be applied in WikiTrust to
create ``author reputations'' for anonymous authors, which we speculate
will improve the performance further.

As shown in~\cite{Adler2011a}, the construction of features is complementary
between WikiTrust and STiki, and performs very well when combined, but the
actual formulas employed to compute reputation are ad hoc in nature.
Is there some principle by which reputation algorithms can be
constructed to give better results?
Or a set of design choices that can be laid out~\cite{Adler2011b} with
known benefits and costs?
How can we choose the scope of entities to construct reputations for?
We leave these questions open to pursue in future works.


% Choosing entities is a lot like choosing failure domains.
% Can we choose entities by building ADTrees and selecting
% high-information decision branches?  Or maybe use the "type"
% of the decision branches to choose the categories?

