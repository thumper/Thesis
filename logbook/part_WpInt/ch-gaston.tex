\chapter{Loading onto Gaston}

\section{Introduction}

\subsection{29-Sep-2010}

Our ``production system'' has been running for several months now,
with the English wikipedia running on Redherring, and several
different languages running on Gaston.
We have recently run into a few bugs that led to a relatively large
overhaul of how revisions are being stored, but we don't have a good
way to test the system.
Luca suggested that I set up a small English installation on Gaston
and use that to test the new code for problems.

\section{Setup}

\subsection{29-Sep-2010}

I have been tracing through Ian's installation files and trying
to organize it to be a bit more portable.
The core definitions are in \file{/etc/wikitrust/},
There are executables and cron files scattered elsewhere, but I am
slowly finding them and noting their installation in
\file{WikiTrust/util/ucsc-install/Makefile}.

Before running a test, the database needs to be setup:
\begin{verbatim}
$ mysql --user root --password mysql
mysql> create database enwiki;
mysql> GRANT ALL PRIVILEGES ON enwikidb.* TO 'wikiuser'@'localhost';
mysql> quit
\end{verbatim}

A directory for the downloaded revisions is also necessary:
\begin{verbatim}
$ cd /raid
$ sudo mkdir enwiki-test
$ sudo chown wikitrust.wikitrust enwiki-test
\end{verbatim}

The database also needs to be initialized with tables.
You can either setup a fullblown mediawiki installation,
or just create the empty datables.
To create the empty tables, use the following:
\begin{verbatim}
$ cd WikiTrust/sql
$ mysql --user wikiuser --password enwikidb
mysql> \. wikitrust.sql
mysql> quit
\end{verbatim}


\section{Debugging}

\subsection{29-Sep-2010}

In order to test things out the way that they would get launched
by the startup scripts, I hacked up a new script that mirrors
the work done by \program{wikitrustd}.
It's called \program{testlaunch} and you use it like so:
\begin{verbatim}
$ cd WikiTrust/remote/admin
$ sudo ./testlaunch enwiki
\end{verbatim}
This is most effective if you edit
\file{/etc/wikitrust/wikis_available.d/enwiki}
so that the \texttt{DISPATCHER} variable is pointing to
the version of the dispatcher compiled in your directory.

While testing out my configuration, I found that the
\program{dispatcher} was immediately terminating because
of a DB exception.
Due to the way that the dispatcher is started, it's a little
difficult to get the stack trace.
To do it, I had to clean my build tree and rebuild the debugging
version of \wikitrust, then modify the \file{enwiki} configuration
to say:
\begin{verbatim}
DISPATCHER="env OCAMLRUNPARAM=b /store/thumper/research/WikiTrust/remote/analysis/dispatcher"
\end{verbatim}
This will generate a stack trace with the exception.

Since I was getting a DB exception, I hacked the config a little
further to add the ``\texttt{-dump_db_calls}'' option.
This led to the discovery that I also need to initialize all
the tables after creating the database.


To add a page to the dispatcher queue, I used:
\begin{verbatim}
env WT_DBNAME=DBI:mysql:database=enwikidb:host=localhost WT_DBUSER=wikiuser WT_DBPASS=wikiword perl -I. -MWikiTrust -e "WikiTrust::cmdline();" method=gettext pageid=3703446
\end{verbatim}

\section{Disk Failure}

\subsection{5-Feb-2011}

We had a power outage at Santa Cruz last November, and Gaston
went down unexpectedly.
When it came back, the database was corruped
(See Section~\ref{ch:mysql-crash}) and I had to dump and restore
to get it working again.

Then the database crashed again, I think in early January,
and I had to repeat the process.

This time, something slightly different happened, and I ended up
trying to run \program{xfs\_repair} on \texttt{/store}.
Well, that seemed to work, until I tried running it again and
discovered that some of the same errors were being discovered again.
This led me to believe that maybe writes aren't making it to the
disk.

Luca called in the SOE TechStaff, but they had similar bad luck
(and they reported no error lights on the hardware).
We've tried to copy the data off the disk, and now the only option
left is to try to reformat.
Luca suggested that we run \program{badblocks} first to actually
test the disk, which seems like a good idea to me:
XFS has a blocksize of 4096~bytes, so I ran \program{badblocks} as:
\begin{verbatim}
# badblocks -b 4096 -o /raid/badblocks.sdb1 -p 1 -w -s -v /dev/sdb1
\end{verbatim}

Heidi also gave us some tips on how to check the health status
of the RAID devices on this machine.
For the external RAID device, the correct check is:
\begin{verbatim}
# smartctl -d scsi --all /dev/sdc
\end{verbatim}
which reports no errors.
On Redherring, the equivalent commands seem to be:
\begin{verbatim}
# smartctl -d 3ware,0 --all /dev/twa0
# smartctl -d 3ware,1 --all /dev/twa1
\end{verbatim}

The RAID which is broken is an internal RAID, and doesn't support
the SMART extensions, so Heidi downloaded a different tool to
access the health status.  This tool is called \program{MegaCli},
but I couldn't figure out the right options to run it with.

